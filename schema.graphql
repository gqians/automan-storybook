"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""All input for the create `MeoteTestPoly` mutation."""
input CreateMeoteTestPolyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MeoteTestPoly` to be created by this mutation."""
  meoteTestPoly: MeoteTestPolyInput!
}

"""The output of our create `MeoteTestPoly` mutation."""
type CreateMeoteTestPolyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeoteTestPoly` that was created by this mutation."""
  meoteTestPoly: MeoteTestPoly

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MeoteTestPoly`. May be used by Relay 1."""
  meoteTestPolyEdge(
    """The method to use when ordering `MeoteTestPoly`."""
    orderBy: [MeoteTestPoliesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeoteTestPoliesEdge
}

"""All input for the create `MeteoTest` mutation."""
input CreateMeteoTestInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MeteoTest` to be created by this mutation."""
  meteoTest: MeteoTestInput!
}

"""The output of our create `MeteoTest` mutation."""
type CreateMeteoTestPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeteoTest` that was created by this mutation."""
  meteoTest: MeteoTest

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MeteoTest`. May be used by Relay 1."""
  meteoTestEdge(
    """The method to use when ordering `MeteoTest`."""
    orderBy: [MeteoTestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeteoTestsEdge
}

"""All input for the create `Powerstation` mutation."""
input CreatePowerstationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Powerstation` to be created by this mutation."""
  powerstation: PowerstationInput!
}

"""The output of our create `Powerstation` mutation."""
type CreatePowerstationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Powerstation` that was created by this mutation."""
  powerstation: Powerstation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Powerstation`. May be used by Relay 1."""
  powerstationEdge(
    """The method to use when ordering `Powerstation`."""
    orderBy: [PowerstationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PowerstationsEdge
}

"""All input for the create `Station` mutation."""
input CreateStationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Station` to be created by this mutation."""
  station: StationInput!
}

"""The output of our create `Station` mutation."""
type CreateStationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Station` that was created by this mutation."""
  station: Station

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Station`. May be used by Relay 1."""
  stationEdge(
    """The method to use when ordering `Station`."""
    orderBy: [StationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StationsEdge
}

input CreateStationsInput {
  station: [StationInput]!
  clientMutationId: String
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""All input for the `deleteMeoteTestPolyByNodeId` mutation."""
input DeleteMeoteTestPolyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MeoteTestPoly` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMeoteTestPoly` mutation."""
input DeleteMeoteTestPolyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `MeoteTestPoly` mutation."""
type DeleteMeoteTestPolyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeoteTestPoly` that was deleted by this mutation."""
  meoteTestPoly: MeoteTestPoly
  deletedMeoteTestPolyNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MeoteTestPoly`. May be used by Relay 1."""
  meoteTestPolyEdge(
    """The method to use when ordering `MeoteTestPoly`."""
    orderBy: [MeoteTestPoliesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeoteTestPoliesEdge
}

"""All input for the `deleteMeteoTestByNodeId` mutation."""
input DeleteMeteoTestByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MeteoTest` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMeteoTest` mutation."""
input DeleteMeteoTestInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `MeteoTest` mutation."""
type DeleteMeteoTestPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeteoTest` that was deleted by this mutation."""
  meteoTest: MeteoTest
  deletedMeteoTestNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MeteoTest`. May be used by Relay 1."""
  meteoTestEdge(
    """The method to use when ordering `MeteoTest`."""
    orderBy: [MeteoTestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeteoTestsEdge
}

"""All input for the `deletePowerstationByNodeId` mutation."""
input DeletePowerstationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Powerstation` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePowerstation` mutation."""
input DeletePowerstationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Powerstation` mutation."""
type DeletePowerstationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Powerstation` that was deleted by this mutation."""
  powerstation: Powerstation
  deletedPowerstationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Powerstation`. May be used by Relay 1."""
  powerstationEdge(
    """The method to use when ordering `Powerstation`."""
    orderBy: [PowerstationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PowerstationsEdge
}

"""All input for the `deleteStationByGeom` mutation."""
input DeleteStationByGeomInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  geom: GeoJSON!
}

"""All input for the `deleteStationByNodeId` mutation."""
input DeleteStationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Station` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStationByStationName` mutation."""
input DeleteStationByStationNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  stationName: String!
}

"""All input for the `deleteStation` mutation."""
input DeleteStationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Station` mutation."""
type DeleteStationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Station` that was deleted by this mutation."""
  station: Station
  deletedStationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Station`. May be used by Relay 1."""
  stationEdge(
    """The method to use when ordering `Station`."""
    orderBy: [StationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StationsEdge
}

"""
The `GeoJSON` scalar type represents GeoJSON values as specified by[RFC 7946](https://tools.ietf.org/html/rfc7946).
"""
scalar GeoJSON

"""All geometry XY types implement this interface"""
interface GeometryGeometry {
  """Converts the object to GeoJSON"""
  geojson: GeoJSON

  """Spatial reference identifier (SRID)"""
  srid: Int!
}

type GeometryGeometryCollection implements GeometryInterface & GeometryGeometry {
  geojson: GeoJSON
  srid: Int!
  geometries: [GeometryGeometry]
}

type GeometryGeometryCollectionM implements GeometryInterface & GeometryGeometryM {
  geojson: GeoJSON
  srid: Int!
  geometries: [GeometryGeometryM]
}

type GeometryGeometryCollectionZ implements GeometryInterface & GeometryGeometryZ {
  geojson: GeoJSON
  srid: Int!
  geometries: [GeometryGeometryZ]
}

type GeometryGeometryCollectionZM implements GeometryInterface & GeometryGeometryZM {
  geojson: GeoJSON
  srid: Int!
  geometries: [GeometryGeometryZM]
}

"""All geometry XYM types implement this interface"""
interface GeometryGeometryM {
  """Converts the object to GeoJSON"""
  geojson: GeoJSON

  """Spatial reference identifier (SRID)"""
  srid: Int!
}

"""All geometry XYZ types implement this interface"""
interface GeometryGeometryZ {
  """Converts the object to GeoJSON"""
  geojson: GeoJSON

  """Spatial reference identifier (SRID)"""
  srid: Int!
}

"""All geometry XYZM types implement this interface"""
interface GeometryGeometryZM {
  """Converts the object to GeoJSON"""
  geojson: GeoJSON

  """Spatial reference identifier (SRID)"""
  srid: Int!
}

"""All geometry types implement this interface"""
interface GeometryInterface {
  """Converts the object to GeoJSON"""
  geojson: GeoJSON

  """Spatial reference identifier (SRID)"""
  srid: Int!
}

"""
A filter to be used against GeometryInterface fields. All fields are combined with a logical ‘and.’
"""
input GeometryInterfaceFilter {
  """Bounding box is strictly above the specified geometry's bounding box."""
  bboxAbove: GeoJSON

  """Bounding box is strictly below the specified geometry's bounding box."""
  bboxBelow: GeoJSON

  """Bounding box contains the specified geometry's bounding box."""
  bboxContains: GeoJSON

  """Bounding box is the same as the specified geometry's bounding box."""
  bboxEquals: GeoJSON

  """2D bounding box intersects the specified geometry's 2D bounding box."""
  bboxIntersects2D: GeoJSON

  """n-D bounding box intersects the specified geometry's n-D bounding box."""
  bboxIntersectsND: GeoJSON

  """
  Bounding box is strictly to the left of the specified geometry's bounding box.
  """
  bboxLeftOf: GeoJSON

  """
  Bounding box overlaps or is above the specified geometry's bounding box.
  """
  bboxOverlapsOrAbove: GeoJSON

  """
  Bounding box overlaps or is below the specified geometry's bounding box.
  """
  bboxOverlapsOrBelow: GeoJSON

  """
  Bounding box overlaps or is to the left of the specified geometry's bounding box.
  """
  bboxOverlapsOrLeftOf: GeoJSON

  """
  Bounding box overlaps or is to the right of the specified geometry's bounding box.
  """
  bboxOverlapsOrRightOf: GeoJSON

  """
  Bounding box is strictly to the right of the specified geometry's bounding box.
  """
  bboxRightOf: GeoJSON

  """
  No points of the specified geometry lie in the exterior, and at least one
  point of the interior of the specified geometry lies in the interior.
  """
  contains: GeoJSON

  """
  The specified geometry intersects the interior but not the boundary (or exterior).
  """
  containsProperly: GeoJSON

  """No point is outside the specified geometry."""
  coveredBy: GeoJSON

  """No point in the specified geometry is outside."""
  covers: GeoJSON

  """They have some, but not all, interior points in common."""
  crosses: GeoJSON

  """They do not share any space together."""
  disjoint: GeoJSON

  """They represent the same geometry. Directionality is ignored."""
  equals: GeoJSON

  """Coordinates and coordinate order are the same as specified geometry."""
  exactlyEquals: GeoJSON

  """They share any portion of space in 2D."""
  intersects: GeoJSON

  """They share any portion of space in 3D."""
  intersects3D: GeoJSON

  """
  They represent the same geometry and points are in the same directional order.
  """
  orderingEquals: GeoJSON

  """
  They share space, are of the same dimension, but are not completely contained by each other.
  """
  overlaps: GeoJSON

  """
  They have at least one point in common, but their interiors do not intersect.
  """
  touches: GeoJSON

  """Completely inside the specified geometry."""
  within: GeoJSON
}

type GeometryLineString implements GeometryInterface & GeometryGeometry {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPoint]
}

type GeometryLineStringM implements GeometryInterface & GeometryGeometryM {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPointM]
}

type GeometryLineStringZ implements GeometryInterface & GeometryGeometryZ {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPointZ]
}

type GeometryLineStringZM implements GeometryInterface & GeometryGeometryZM {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPointZM]
}

type GeometryMultiLineString implements GeometryInterface & GeometryGeometry {
  geojson: GeoJSON
  srid: Int!
  lines: [GeometryLineString]
}

type GeometryMultiLineStringM implements GeometryInterface & GeometryGeometryM {
  geojson: GeoJSON
  srid: Int!
  lines: [GeometryLineStringM]
}

type GeometryMultiLineStringZ implements GeometryInterface & GeometryGeometryZ {
  geojson: GeoJSON
  srid: Int!
  lines: [GeometryLineStringZ]
}

type GeometryMultiLineStringZM implements GeometryInterface & GeometryGeometryZM {
  geojson: GeoJSON
  srid: Int!
  lines: [GeometryLineStringZM]
}

type GeometryMultiPoint implements GeometryInterface & GeometryGeometry {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPoint]
}

type GeometryMultiPointM implements GeometryInterface & GeometryGeometryM {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPointM]
}

type GeometryMultiPointZ implements GeometryInterface & GeometryGeometryZ {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPointZ]
}

type GeometryMultiPointZM implements GeometryInterface & GeometryGeometryZM {
  geojson: GeoJSON
  srid: Int!
  points: [GeometryPointZM]
}

type GeometryMultiPolygon implements GeometryInterface & GeometryGeometry {
  geojson: GeoJSON
  srid: Int!
  polygons: [GeometryPolygon]
}

"""
A filter to be used against GeometryMultiPolygon fields. All fields are combined with a logical ‘and.’
"""
input GeometryMultiPolygonFilter {
  """Bounding box is strictly above the specified geometry's bounding box."""
  bboxAbove: GeoJSON

  """Bounding box is strictly below the specified geometry's bounding box."""
  bboxBelow: GeoJSON

  """Bounding box contains the specified geometry's bounding box."""
  bboxContains: GeoJSON

  """Bounding box is the same as the specified geometry's bounding box."""
  bboxEquals: GeoJSON

  """2D bounding box intersects the specified geometry's 2D bounding box."""
  bboxIntersects2D: GeoJSON

  """n-D bounding box intersects the specified geometry's n-D bounding box."""
  bboxIntersectsND: GeoJSON

  """
  Bounding box is strictly to the left of the specified geometry's bounding box.
  """
  bboxLeftOf: GeoJSON

  """
  Bounding box overlaps or is above the specified geometry's bounding box.
  """
  bboxOverlapsOrAbove: GeoJSON

  """
  Bounding box overlaps or is below the specified geometry's bounding box.
  """
  bboxOverlapsOrBelow: GeoJSON

  """
  Bounding box overlaps or is to the left of the specified geometry's bounding box.
  """
  bboxOverlapsOrLeftOf: GeoJSON

  """
  Bounding box overlaps or is to the right of the specified geometry's bounding box.
  """
  bboxOverlapsOrRightOf: GeoJSON

  """
  Bounding box is strictly to the right of the specified geometry's bounding box.
  """
  bboxRightOf: GeoJSON

  """
  No points of the specified geometry lie in the exterior, and at least one
  point of the interior of the specified geometry lies in the interior.
  """
  contains: GeoJSON

  """
  The specified geometry intersects the interior but not the boundary (or exterior).
  """
  containsProperly: GeoJSON

  """No point is outside the specified geometry."""
  coveredBy: GeoJSON

  """No point in the specified geometry is outside."""
  covers: GeoJSON

  """They have some, but not all, interior points in common."""
  crosses: GeoJSON

  """They do not share any space together."""
  disjoint: GeoJSON

  """They represent the same geometry. Directionality is ignored."""
  equals: GeoJSON

  """Coordinates and coordinate order are the same as specified geometry."""
  exactlyEquals: GeoJSON

  """They share any portion of space in 2D."""
  intersects: GeoJSON

  """They share any portion of space in 3D."""
  intersects3D: GeoJSON

  """
  They represent the same geometry and points are in the same directional order.
  """
  orderingEquals: GeoJSON

  """
  They share space, are of the same dimension, but are not completely contained by each other.
  """
  overlaps: GeoJSON

  """
  They have at least one point in common, but their interiors do not intersect.
  """
  touches: GeoJSON

  """Completely inside the specified geometry."""
  within: GeoJSON
}

type GeometryMultiPolygonM implements GeometryInterface & GeometryGeometryM {
  geojson: GeoJSON
  srid: Int!
  polygons: [GeometryPolygonM]
}

type GeometryMultiPolygonZ implements GeometryInterface & GeometryGeometryZ {
  geojson: GeoJSON
  srid: Int!
  polygons: [GeometryPolygonZ]
}

type GeometryMultiPolygonZM implements GeometryInterface & GeometryGeometryZM {
  geojson: GeoJSON
  srid: Int!
  polygons: [GeometryPolygonZM]
}

type GeometryPoint implements GeometryInterface & GeometryGeometry {
  geojson: GeoJSON
  srid: Int!
  x: Float!
  y: Float!
}

"""
A filter to be used against GeometryPoint fields. All fields are combined with a logical ‘and.’
"""
input GeometryPointFilter {
  """Bounding box is strictly above the specified geometry's bounding box."""
  bboxAbove: GeoJSON

  """Bounding box is strictly below the specified geometry's bounding box."""
  bboxBelow: GeoJSON

  """Bounding box contains the specified geometry's bounding box."""
  bboxContains: GeoJSON

  """Bounding box is the same as the specified geometry's bounding box."""
  bboxEquals: GeoJSON

  """2D bounding box intersects the specified geometry's 2D bounding box."""
  bboxIntersects2D: GeoJSON

  """n-D bounding box intersects the specified geometry's n-D bounding box."""
  bboxIntersectsND: GeoJSON

  """
  Bounding box is strictly to the left of the specified geometry's bounding box.
  """
  bboxLeftOf: GeoJSON

  """
  Bounding box overlaps or is above the specified geometry's bounding box.
  """
  bboxOverlapsOrAbove: GeoJSON

  """
  Bounding box overlaps or is below the specified geometry's bounding box.
  """
  bboxOverlapsOrBelow: GeoJSON

  """
  Bounding box overlaps or is to the left of the specified geometry's bounding box.
  """
  bboxOverlapsOrLeftOf: GeoJSON

  """
  Bounding box overlaps or is to the right of the specified geometry's bounding box.
  """
  bboxOverlapsOrRightOf: GeoJSON

  """
  Bounding box is strictly to the right of the specified geometry's bounding box.
  """
  bboxRightOf: GeoJSON

  """
  No points of the specified geometry lie in the exterior, and at least one
  point of the interior of the specified geometry lies in the interior.
  """
  contains: GeoJSON

  """
  The specified geometry intersects the interior but not the boundary (or exterior).
  """
  containsProperly: GeoJSON

  """No point is outside the specified geometry."""
  coveredBy: GeoJSON

  """No point in the specified geometry is outside."""
  covers: GeoJSON

  """They have some, but not all, interior points in common."""
  crosses: GeoJSON

  """They do not share any space together."""
  disjoint: GeoJSON

  """They represent the same geometry. Directionality is ignored."""
  equals: GeoJSON

  """Coordinates and coordinate order are the same as specified geometry."""
  exactlyEquals: GeoJSON

  """They share any portion of space in 2D."""
  intersects: GeoJSON

  """They share any portion of space in 3D."""
  intersects3D: GeoJSON

  """
  They represent the same geometry and points are in the same directional order.
  """
  orderingEquals: GeoJSON

  """
  They share space, are of the same dimension, but are not completely contained by each other.
  """
  overlaps: GeoJSON

  """
  They have at least one point in common, but their interiors do not intersect.
  """
  touches: GeoJSON

  """Completely inside the specified geometry."""
  within: GeoJSON
}

type GeometryPointM implements GeometryInterface & GeometryGeometryM {
  geojson: GeoJSON
  srid: Int!
  x: Float!
  y: Float!
}

type GeometryPointZ implements GeometryInterface & GeometryGeometryZ {
  geojson: GeoJSON
  srid: Int!
  x: Float!
  y: Float!
}

type GeometryPointZM implements GeometryInterface & GeometryGeometryZM {
  geojson: GeoJSON
  srid: Int!
  x: Float!
  y: Float!
}

type GeometryPolygon implements GeometryInterface & GeometryGeometry {
  geojson: GeoJSON
  srid: Int!
  exterior: GeometryLineString
  interiors: [GeometryLineString]
}

type GeometryPolygonM implements GeometryInterface & GeometryGeometryM {
  geojson: GeoJSON
  srid: Int!
  exterior: GeometryLineStringM
  interiors: [GeometryLineStringM]
}

type GeometryPolygonZ implements GeometryInterface & GeometryGeometryZ {
  geojson: GeoJSON
  srid: Int!
  exterior: GeometryLineStringZ
  interiors: [GeometryLineStringZ]
}

type GeometryPolygonZM implements GeometryInterface & GeometryGeometryZM {
  geojson: GeoJSON
  srid: Int!
  exterior: GeometryLineStringZM
  interiors: [GeometryLineStringZM]
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""A connection to a list of `MeoteTestPoly` values."""
type MeoteTestPoliesConnection {
  """A list of `MeoteTestPoly` objects."""
  nodes: [MeoteTestPoly!]!

  """
  A list of edges which contains the `MeoteTestPoly` and cursor to aid in pagination.
  """
  edges: [MeoteTestPoliesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MeoteTestPoly` you could get from the connection."""
  totalCount: Int!
}

"""A `MeoteTestPoly` edge in the connection."""
type MeoteTestPoliesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MeoteTestPoly` at the end of the edge."""
  node: MeoteTestPoly!
}

"""Methods to use when ordering `MeoteTestPoly`."""
enum MeoteTestPoliesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GEOM_ASC
  GEOM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type MeoteTestPoly implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  geom: GeometryMultiPolygon
}

"""
A condition to be used against `MeoteTestPoly` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input MeoteTestPolyCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `geom` field."""
  geom: GeoJSON
}

"""
A filter to be used against `MeoteTestPoly` object types. All fields are combined with a logical ‘and.’
"""
input MeoteTestPolyFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `geom` field."""
  geom: GeometryMultiPolygonFilter

  """Checks for all expressions in this list."""
  and: [MeoteTestPolyFilter!]

  """Checks for any expressions in this list."""
  or: [MeoteTestPolyFilter!]

  """Negates the expression."""
  not: MeoteTestPolyFilter
}

"""An input for mutations affecting `MeoteTestPoly`"""
input MeoteTestPolyInput {
  id: Int!
  geom: GeoJSON
}

"""
Represents an update to a `MeoteTestPoly`. Fields that are set will be updated.
"""
input MeoteTestPolyPatch {
  id: Int
  geom: GeoJSON
}

type MeteoTest implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  geom: GeometryPoint
}

"""
A condition to be used against `MeteoTest` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MeteoTestCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `geom` field."""
  geom: GeoJSON
}

"""
A filter to be used against `MeteoTest` object types. All fields are combined with a logical ‘and.’
"""
input MeteoTestFilter {
  """Filter by the object’s `id` field."""
  id: BigIntFilter

  """Filter by the object’s `geom` field."""
  geom: GeometryPointFilter

  """Checks for all expressions in this list."""
  and: [MeteoTestFilter!]

  """Checks for any expressions in this list."""
  or: [MeteoTestFilter!]

  """Negates the expression."""
  not: MeteoTestFilter
}

"""An input for mutations affecting `MeteoTest`"""
input MeteoTestInput {
  id: BigInt!
  geom: GeoJSON
}

"""
Represents an update to a `MeteoTest`. Fields that are set will be updated.
"""
input MeteoTestPatch {
  id: BigInt
  geom: GeoJSON
}

"""A connection to a list of `MeteoTest` values."""
type MeteoTestsConnection {
  """A list of `MeteoTest` objects."""
  nodes: [MeteoTest!]!

  """
  A list of edges which contains the `MeteoTest` and cursor to aid in pagination.
  """
  edges: [MeteoTestsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MeteoTest` you could get from the connection."""
  totalCount: Int!
}

"""A `MeteoTest` edge in the connection."""
type MeteoTestsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MeteoTest` at the end of the edge."""
  node: MeteoTest!
}

"""Methods to use when ordering `MeteoTest`."""
enum MeteoTestsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GEOM_ASC
  GEOM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `MeoteTestPoly`."""
  createMeoteTestPoly(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMeoteTestPolyInput!
  ): CreateMeoteTestPolyPayload

  """Creates a single `MeteoTest`."""
  createMeteoTest(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMeteoTestInput!
  ): CreateMeteoTestPayload

  """Creates a single `Powerstation`."""
  createPowerstation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePowerstationInput!
  ): CreatePowerstationPayload

  """Creates a single `Station`."""
  createStation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStationInput!
  ): CreateStationPayload

  """
  Updates a single `MeoteTestPoly` using its globally unique id and a patch.
  """
  updateMeoteTestPolyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMeoteTestPolyByNodeIdInput!
  ): UpdateMeoteTestPolyPayload

  """Updates a single `MeoteTestPoly` using a unique key and a patch."""
  updateMeoteTestPoly(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMeoteTestPolyInput!
  ): UpdateMeoteTestPolyPayload

  """Updates a single `MeteoTest` using its globally unique id and a patch."""
  updateMeteoTestByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMeteoTestByNodeIdInput!
  ): UpdateMeteoTestPayload

  """Updates a single `MeteoTest` using a unique key and a patch."""
  updateMeteoTest(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMeteoTestInput!
  ): UpdateMeteoTestPayload

  """
  Updates a single `Powerstation` using its globally unique id and a patch.
  """
  updatePowerstationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePowerstationByNodeIdInput!
  ): UpdatePowerstationPayload

  """Updates a single `Powerstation` using a unique key and a patch."""
  updatePowerstation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePowerstationInput!
  ): UpdatePowerstationPayload

  """Updates a single `Station` using its globally unique id and a patch."""
  updateStationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStationByNodeIdInput!
  ): UpdateStationPayload

  """Updates a single `Station` using a unique key and a patch."""
  updateStation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStationInput!
  ): UpdateStationPayload

  """Updates a single `Station` using a unique key and a patch."""
  updateStationByGeom(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStationByGeomInput!
  ): UpdateStationPayload

  """Updates a single `Station` using a unique key and a patch."""
  updateStationByStationName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStationByStationNameInput!
  ): UpdateStationPayload

  """Deletes a single `MeoteTestPoly` using its globally unique id."""
  deleteMeoteTestPolyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMeoteTestPolyByNodeIdInput!
  ): DeleteMeoteTestPolyPayload

  """Deletes a single `MeoteTestPoly` using a unique key."""
  deleteMeoteTestPoly(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMeoteTestPolyInput!
  ): DeleteMeoteTestPolyPayload

  """Deletes a single `MeteoTest` using its globally unique id."""
  deleteMeteoTestByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMeteoTestByNodeIdInput!
  ): DeleteMeteoTestPayload

  """Deletes a single `MeteoTest` using a unique key."""
  deleteMeteoTest(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMeteoTestInput!
  ): DeleteMeteoTestPayload

  """Deletes a single `Powerstation` using its globally unique id."""
  deletePowerstationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePowerstationByNodeIdInput!
  ): DeletePowerstationPayload

  """Deletes a single `Powerstation` using a unique key."""
  deletePowerstation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePowerstationInput!
  ): DeletePowerstationPayload

  """Deletes a single `Station` using its globally unique id."""
  deleteStationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStationByNodeIdInput!
  ): DeleteStationPayload

  """Deletes a single `Station` using a unique key."""
  deleteStation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStationInput!
  ): DeleteStationPayload

  """Deletes a single `Station` using a unique key."""
  deleteStationByGeom(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStationByGeomInput!
  ): DeleteStationPayload

  """Deletes a single `Station` using a unique key."""
  deleteStationByStationName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStationByStationNameInput!
  ): DeleteStationPayload
  InsertPoints(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStationsInput!
  ): CreateStationPayload
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type Powerstation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  geom: GeometryInterface!
}

"""
A condition to be used against `Powerstation` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PowerstationCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `geom` field."""
  geom: GeoJSON
}

"""
A filter to be used against `Powerstation` object types. All fields are combined with a logical ‘and.’
"""
input PowerstationFilter {
  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `geom` field."""
  geom: GeometryInterfaceFilter

  """Checks for all expressions in this list."""
  and: [PowerstationFilter!]

  """Checks for any expressions in this list."""
  or: [PowerstationFilter!]

  """Negates the expression."""
  not: PowerstationFilter
}

"""An input for mutations affecting `Powerstation`"""
input PowerstationInput {
  id: Int
  geom: GeoJSON!
}

"""
Represents an update to a `Powerstation`. Fields that are set will be updated.
"""
input PowerstationPatch {
  id: Int
  geom: GeoJSON
}

"""A connection to a list of `Powerstation` values."""
type PowerstationsConnection {
  """A list of `Powerstation` objects."""
  nodes: [Powerstation!]!

  """
  A list of edges which contains the `Powerstation` and cursor to aid in pagination.
  """
  edges: [PowerstationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Powerstation` you could get from the connection."""
  totalCount: Int!
}

"""A `Powerstation` edge in the connection."""
type PowerstationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Powerstation` at the end of the edge."""
  node: Powerstation!
}

"""Methods to use when ordering `Powerstation`."""
enum PowerstationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GEOM_ASC
  GEOM_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `MeoteTestPoly`."""
  meoteTestPolies(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MeoteTestPoly`."""
    orderBy: [MeoteTestPoliesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeoteTestPolyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeoteTestPolyFilter
  ): MeoteTestPoliesConnection

  """Reads and enables pagination through a set of `MeteoTest`."""
  meteoTests(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MeteoTest`."""
    orderBy: [MeteoTestsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MeteoTestCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MeteoTestFilter
  ): MeteoTestsConnection

  """Reads and enables pagination through a set of `Powerstation`."""
  powerstations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Powerstation`."""
    orderBy: [PowerstationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PowerstationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PowerstationFilter
  ): PowerstationsConnection

  """Reads and enables pagination through a set of `Station`."""
  stations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Station`."""
    orderBy: [StationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: StationFilter
  ): StationsConnection
  meoteTestPoly(id: Int!): MeoteTestPoly
  meteoTest(id: BigInt!): MeteoTest
  powerstation(id: Int!): Powerstation
  station(id: UUID!): Station
  stationByGeom(geom: GeoJSON!): Station
  stationByStationName(stationName: String!): Station

  """Reads a single `MeoteTestPoly` using its globally unique `ID`."""
  meoteTestPolyByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `MeoteTestPoly`.
    """
    nodeId: ID!
  ): MeoteTestPoly

  """Reads a single `MeteoTest` using its globally unique `ID`."""
  meteoTestByNodeId(
    """The globally unique `ID` to be used in selecting a single `MeteoTest`."""
    nodeId: ID!
  ): MeteoTest

  """Reads a single `Powerstation` using its globally unique `ID`."""
  powerstationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Powerstation`.
    """
    nodeId: ID!
  ): Powerstation

  """Reads a single `Station` using its globally unique `ID`."""
  stationByNodeId(
    """The globally unique `ID` to be used in selecting a single `Station`."""
    nodeId: ID!
  ): Station
}

type Station implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  geom: GeometryInterface!
  stationName: String!
  kCode: String
  address: String
}

"""
A condition to be used against `Station` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StationCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `geom` field."""
  geom: GeoJSON

  """Checks for equality with the object’s `stationName` field."""
  stationName: String

  """Checks for equality with the object’s `kCode` field."""
  kCode: String

  """Checks for equality with the object’s `address` field."""
  address: String
}

"""
A filter to be used against `Station` object types. All fields are combined with a logical ‘and.’
"""
input StationFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `geom` field."""
  geom: GeometryInterfaceFilter

  """Filter by the object’s `stationName` field."""
  stationName: StringFilter

  """Filter by the object’s `kCode` field."""
  kCode: StringFilter

  """Filter by the object’s `address` field."""
  address: StringFilter

  """Checks for all expressions in this list."""
  and: [StationFilter!]

  """Checks for any expressions in this list."""
  or: [StationFilter!]

  """Negates the expression."""
  not: StationFilter
}

"""An input for mutations affecting `Station`"""
input StationInput {
  id: UUID
  geom: GeoJSON!
  stationName: String!
  kCode: String
  address: String
}

"""
Represents an update to a `Station`. Fields that are set will be updated.
"""
input StationPatch {
  id: UUID
  geom: GeoJSON
  stationName: String
  kCode: String
  address: String
}

"""A connection to a list of `Station` values."""
type StationsConnection {
  """A list of `Station` objects."""
  nodes: [Station!]!

  """
  A list of edges which contains the `Station` and cursor to aid in pagination.
  """
  edges: [StationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Station` you could get from the connection."""
  totalCount: Int!
}

"""A `Station` edge in the connection."""
type StationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Station` at the end of the edge."""
  node: Station!
}

"""Methods to use when ordering `Station`."""
enum StationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GEOM_ASC
  GEOM_DESC
  STATION_NAME_ASC
  STATION_NAME_DESC
  K_CODE_ASC
  K_CODE_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any
  single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_)
  matches any single character; a percent sign (%) matches any sequence of zero
  or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches
  any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_)
  matches any single character; a percent sign (%) matches any sequence of zero
  or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""All input for the `updateMeoteTestPolyByNodeId` mutation."""
input UpdateMeoteTestPolyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MeoteTestPoly` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `MeoteTestPoly` being updated.
  """
  patch: MeoteTestPolyPatch!
}

"""All input for the `updateMeoteTestPoly` mutation."""
input UpdateMeoteTestPolyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MeoteTestPoly` being updated.
  """
  patch: MeoteTestPolyPatch!
  id: Int!
}

"""The output of our update `MeoteTestPoly` mutation."""
type UpdateMeoteTestPolyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeoteTestPoly` that was updated by this mutation."""
  meoteTestPoly: MeoteTestPoly

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MeoteTestPoly`. May be used by Relay 1."""
  meoteTestPolyEdge(
    """The method to use when ordering `MeoteTestPoly`."""
    orderBy: [MeoteTestPoliesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeoteTestPoliesEdge
}

"""All input for the `updateMeteoTestByNodeId` mutation."""
input UpdateMeteoTestByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MeteoTest` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `MeteoTest` being updated.
  """
  patch: MeteoTestPatch!
}

"""All input for the `updateMeteoTest` mutation."""
input UpdateMeteoTestInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MeteoTest` being updated.
  """
  patch: MeteoTestPatch!
  id: BigInt!
}

"""The output of our update `MeteoTest` mutation."""
type UpdateMeteoTestPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MeteoTest` that was updated by this mutation."""
  meteoTest: MeteoTest

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `MeteoTest`. May be used by Relay 1."""
  meteoTestEdge(
    """The method to use when ordering `MeteoTest`."""
    orderBy: [MeteoTestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeteoTestsEdge
}

"""All input for the `updatePowerstationByNodeId` mutation."""
input UpdatePowerstationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Powerstation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Powerstation` being updated.
  """
  patch: PowerstationPatch!
}

"""All input for the `updatePowerstation` mutation."""
input UpdatePowerstationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Powerstation` being updated.
  """
  patch: PowerstationPatch!
  id: Int!
}

"""The output of our update `Powerstation` mutation."""
type UpdatePowerstationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Powerstation` that was updated by this mutation."""
  powerstation: Powerstation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Powerstation`. May be used by Relay 1."""
  powerstationEdge(
    """The method to use when ordering `Powerstation`."""
    orderBy: [PowerstationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PowerstationsEdge
}

"""All input for the `updateStationByGeom` mutation."""
input UpdateStationByGeomInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Station` being updated.
  """
  patch: StationPatch!
  geom: GeoJSON!
}

"""All input for the `updateStationByNodeId` mutation."""
input UpdateStationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Station` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Station` being updated.
  """
  patch: StationPatch!
}

"""All input for the `updateStationByStationName` mutation."""
input UpdateStationByStationNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Station` being updated.
  """
  patch: StationPatch!
  stationName: String!
}

"""All input for the `updateStation` mutation."""
input UpdateStationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Station` being updated.
  """
  patch: StationPatch!
  id: UUID!
}

"""The output of our update `Station` mutation."""
type UpdateStationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Station` that was updated by this mutation."""
  station: Station

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Station`. May be used by Relay 1."""
  stationEdge(
    """The method to use when ordering `Station`."""
    orderBy: [StationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StationsEdge
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A filter to be used against UUID fields. All fields are combined with a logical ‘and.’
"""
input UUIDFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}
